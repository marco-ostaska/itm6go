// Package parsesitxml is a pacakge to parse the xml
// generated by tacmd viewsit -s <sit> -e <xml>
// or bulk export xmls
package parsesitxml

import (
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
)

// Situations struct to parse the situation xml
// ROW contains all tags from exported xml
type Situations struct {
	XMLName xml.Name `xml:"TABLE"`
	Text    string   `xml:",chardata"`
	ROW     row      `xml:"ROW"`
}

type row struct {
	Text         string `xml:",chardata"`
	SITNAME      string `xml:"SITNAME"`
	FULLNAME     string `xml:"FULLNAME"`
	ADVISE       string `xml:"ADVISE"`
	AFFINITIES   string `xml:"AFFINITIES"`
	ALERTLIST    string `xml:"ALERTLIST"`
	AUTOSOPT     string `xml:"AUTOSOPT"`
	AUTOSTART    string `xml:"AUTOSTART"`
	CMD          string `xml:"CMD"`
	DESTNODE     string `xml:"DESTNODE"`
	HUB          string `xml:"HUB"`
	LOCFLAG      string `xml:"LOCFLAG"`
	LSTCCSID     string `xml:"LSTCCSID"`
	LSTDATE      string `xml:"LSTDATE"`
	LSTRELEASE   string `xml:"LSTRELEASE"`
	LSTUSRPRF    string `xml:"LSTUSRPRF"`
	NOTIFYARGS   string `xml:"NOTIFYARGS"`
	NOTIFYOPTS   string `xml:"NOTIFYOPTS"`
	OBJECTLOCK   string `xml:"OBJECTLOCK"`
	PDT          string `xml:"PDT"`
	PRNAMES      string `xml:"PRNAMES"`
	QIBSCOPE     string `xml:"QIBSCOPE"`
	REEVDAYS     string `xml:"REEV_DAYS"`
	REEVTIME     string `xml:"REEV_TIME"`
	REFLEXOK     string `xml:"REFLEXOK"`
	SENDMSGQ     string `xml:"SENDMSGQ"`
	SITINFO      string `xml:"SITINFO"`
	SOURCE       string `xml:"SOURCE"`
	TEXT         string `xml:"TEXT"`
	DISTRIBUTION string `xml:"DISTRIBUTION"`
}

// ParseLstDate parse <LSTDATE> to mm/dd/yy HH:mm:ss
func (s *Situations) ParseLstDate() (string, error) {
	ds := []byte(s.ROW.LSTDATE)
	if len(ds) < 13 {
		return "", fmt.Errorf("s.ROW.LSTDATE out of range")
	}
	return fmt.Sprintf("%s/%s/%s %s:%s:%s",
		ds[3:5], ds[5:7], ds[1:3],
		ds[7:9], ds[9:11], ds[11:13]), nil
}

//ParseSitXML parse the xml for the given situation
func ParseSitXML(s string) (Situations, error) {
	var sit Situations
	abs, err := filepath.Abs(s)

	if err != nil {
		return sit, err
	}

	xmlFile, err := os.Open(filepath.Clean(abs))
	if err != nil {
		return sit, err
	}
	defer xmlClose(xmlFile)

	byteValue, err := ioutil.ReadAll(xmlFile)

	if err != nil {
		return sit, err
	}

	err = xml.Unmarshal(byteValue, &sit)

	return sit, err

}

func xmlClose(f *os.File) {
	err := f.Close()

	if err != nil {
		log.Fatalln(err)
	}
}
